import {mockCourseData} from "@/canvas/course/__mocks__/mockCourseData";

//Generated by ChatGPT 3.5

// PublishInterface.test.tsx
// eslint-disable-next-line @/no-undef,@typescript-eslint/no-require-imports
global.TextEncoder = require('util').TextEncoder;

import React, {act} from 'react';
import {render, screen, fireEvent, waitFor} from '@testing-library/react';
import '@testing-library/jest-dom';
import {PublishInterface, IPublishInterfaceProps, OpenButton} from '../PublishInterface';
import {IUserData} from '@/canvas/canvasDataDefs';
import {Course} from "@/canvas/course/Course";


import fetchMock from "jest-fetch-mock";
import publishEmailMock from "@/publish/publishInterface/__mocks__/publishEmailMock";

import {SectionData} from "@/canvas/courseTypes";
import {mockAsyncGen} from "@/__mocks__/utils";


fetchMock.enableMocks();
const mockCourse: Course = new Course({
    ...mockCourseData,
    id: 1,
    name: 'BP_TEST000: Test Course',
    course_code: 'BP_TEST',
    blueprint: true,

}) as Course;

jest.mock('@/canvas/course/blueprint', () => ({
    ...jest.requireActual('@/canvas/course/blueprint'),
    sectionDataGenerator: jest.fn(() => mockAsyncGen([] as SectionData[])),
}))

jest.mock(
  '@/publish/publishInterface/EmailLink',
  () => ({ EmailLink: () => null })
);


const mockUser: IUserData = {
    id: 1,
    name: 'Test User',
    email: 'test@example.com',
} as IUserData;

const renderComponent = (props: Partial<IPublishInterfaceProps> = {}) => {
    const defaultProps: IPublishInterfaceProps = {
        course: mockCourse,
        user: mockUser,
        ...props,
    };

    return act(() => render(<PublishInterface {...defaultProps} />));
};

describe('PublishInterface Component', () => {
    it('renders without crashing', async () => {
        await renderComponent();
        expect(screen.getByText('Manage Sections')).toBeInTheDocument();
    });

    it('opens modal when "Manage Sections" button is clicked', async () => {
        await renderComponent();
        await act(async () => fireEvent.click(screen.getByText('Manage Sections')));
        expect(screen.getByText('Sections')).toBeInTheDocument();
    });

    it('displays loading state when publishing courses', async () => {

        fetchMock.mockResponse(publishEmailMock);
        await renderComponent();
        await act(async () => {
            fireEvent.click(screen.getByText('Manage Sections'));
        });
        fetchMock.mockResponse(JSON.stringify(mockCourseData))
        await act(async () => {
            fireEvent.click(screen.getByText('Publish all'));
        });
        await waitFor(() => screen.getByRole('alert'));
        expect(screen.getByText('Publishing')).toBeInTheDocument();
        // Simulate delay for publishing
        await waitFor(() => screen.getByText(/Published/i));
        expect(screen.getByText(/Published \d+ sections/)).toBeInTheDocument();
    });

    it('calls applySectionProfiles when "Set Bios" button is clicked', async () => {
        await renderComponent();
        await act(async () => fireEvent.click(screen.getByText('Manage Sections')));
        await act(async () => fireEvent.click(screen.getByText('Set Bios')));
        // Simulate delay for applying section profiles
        await new Promise(resolve => setTimeout(resolve, 100));
        expect(screen.getByText('Profiles Updated')).toBeInTheDocument();
    });
});

describe('OpenButton Component', () => {
    test('should render with "Not BP or DEV" label when isBlueprint and isDev are false', async () => {
        await act(async () => {
            render(<OpenButton isDev={false} isBlueprint={false} setShow={jest.fn()}/>);
        });
        expect(screen.getByText('Not BP or DEV')).toBeInTheDocument();
    });

    test('should render with "Manage Sections" label when isBlueprint is true', async () => {
        await act(async () => render(<OpenButton isDev={false} isBlueprint={true} setShow={jest.fn()}/>));
        expect(screen.getByText('Manage Sections')).toBeInTheDocument();
    });

    test('should render with "Manage DEV->BP" label when isDev is true', async () => {
        await act(async () => render(<OpenButton isDev={true} isBlueprint={false} setShow={jest.fn()}/>));
        expect(screen.getByText('Manage DEV->BP')).toBeInTheDocument();
    });

    test('should enable button when isBlueprint or isDev is true', async () => {
        let rerender: (ReturnType<typeof render>['rerender']);
        await act(async () => {
            rerender = render(<OpenButton isDev={false} isBlueprint={false} setShow={jest.fn()}/>).rerender;

        });
        expect(screen.getByRole('button')).toBeDisabled();

        await act(async () => rerender!(<OpenButton isDev={true} isBlueprint={false} setShow={jest.fn()}/>));
        expect(screen.getByRole('button')).not.toBeDisabled();

        await act(async () => rerender!(<OpenButton isDev={false} isBlueprint={true} setShow={jest.fn()}/>));
        expect(screen.getByRole('button')).not.toBeDisabled();
    });

    test('should call setShow with true when button is clicked and not disabled', async () => {
        const setShowMock = jest.fn();
        await act(async () => render(<OpenButton isDev={true} isBlueprint={false} setShow={setShowMock}/>));
        await act(async () => fireEvent.click(screen.getByRole('button')));
        expect(setShowMock).toHaveBeenCalledWith(true);
    });

    test('should not call setShow when button is disabled and clicked', async () => {
        const setShowMock = jest.fn();
        await act(async () => render(<OpenButton isDev={false} isBlueprint={false} setShow={setShowMock}/>));
        await act(async () => fireEvent.click(screen.getByRole('button')));
        expect(setShowMock).not.toHaveBeenCalled();
    });
});