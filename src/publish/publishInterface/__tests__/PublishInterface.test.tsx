import {mockCourseData} from "../../../canvas/course/__mocks__/mockCourseData";

//Generated by ChatGPT 3.5

// PublishInterface.test.tsx
global.TextEncoder = require('util').TextEncoder;

import React from 'react';
import {render, screen, fireEvent, waitFor} from '@testing-library/react';
import '@testing-library/jest-dom';
import {PublishInterface, IPublishInterfaceProps, OpenButton} from '../PublishInterface';
import {ICourseData, IUserData} from '../../../canvas/canvasDataDefs';
import {Course} from "../../../canvas/course/Course";


import fetchMock from "jest-fetch-mock";
import publishEmailMock from "@/publish/publishInterface/__mocks__/publishEmailMock";

fetchMock.enableMocks();
const mockCourse: Course = new Course({
    ...mockCourseData,
    id: 1,
    name: 'BP_TEST000: Test Course',
    course_code: 'BP_TEST',
    blueprint: true,

}) as Course;
mockCourse.getAssociatedCourses = jest.fn().mockResolvedValue([]);


function getMockCourse(data:Partial<ICourseData>, associatedCourses: Course[] = []) {
    const course = new Course({
        ...mockCourseData,
        ...data,
    });
    course.getItem = jest.fn();
    course.getAssociatedCourses = jest.fn().mockResolvedValue(associatedCourses)
    return course;
}

const mockUser: IUserData = {
    id: 1,
    name: 'Test User',
    email: 'test@example.com',
} as IUserData;

const renderComponent = (props: Partial<IPublishInterfaceProps> = {}) => {
    const defaultProps: IPublishInterfaceProps = {
        course: mockCourse,
        user: mockUser,
        ...props,
    };

    return render(<PublishInterface {...defaultProps} />);
};

describe('PublishInterface Component', () => {
    it('renders without crashing', () => {
        renderComponent();
        expect(screen.getByText('Manage Sections')).toBeInTheDocument();
    });

    it('opens modal when "Manage Sections" button is clicked', () => {
        renderComponent();
        fireEvent.click(screen.getByText('Manage Sections'));
        expect(screen.getByText('Sections')).toBeInTheDocument();
    });

    it('displays loading state when publishing courses', async () => {

        fetchMock.mockResponse(publishEmailMock);
        renderComponent();
        fireEvent.click(screen.getByText('Manage Sections'));
        fireEvent.click(screen.getByText('Publish'));
        await waitFor(() => screen.getByRole('alert'));
        expect(screen.getByText('Publishing')).toBeInTheDocument();
        // Simulate delay for publishing
        await waitFor(() => screen.getByText(/Published/i));
        expect(screen.getByText('Published')).toBeInTheDocument();
    });

    it('calls applySectionProfiles when "Set Bios" button is clicked', async () => {
        renderComponent();
        fireEvent.click(screen.getByText('Manage Sections'));
        fireEvent.click(screen.getByText('Set Bios'));
        // Simulate delay for applying section profiles
        await new Promise(resolve => setTimeout(resolve, 100));
        expect(screen.getByText('Profiles Updated')).toBeInTheDocument();
    });
});

describe('OpenButton Component', () => {
    test('should render with "Not BP or DEV" label when isBlueprint and isDev are false', () => {
        render(<OpenButton isDev={false} isBlueprint={false} setShow={jest.fn()} />);
        expect(screen.getByText('Not BP or DEV')).toBeInTheDocument();
    });

    test('should render with "Manage Sections" label when isBlueprint is true', () => {
        render(<OpenButton isDev={false} isBlueprint={true} setShow={jest.fn()} />);
        expect(screen.getByText('Manage Sections')).toBeInTheDocument();
    });

    test('should render with "Manage DEV->BP" label when isDev is true', () => {
        render(<OpenButton isDev={true} isBlueprint={false} setShow={jest.fn()} />);
        expect(screen.getByText('Manage DEV->BP')).toBeInTheDocument();
    });

    test('should enable button when isBlueprint or isDev is true', () => {
        const { rerender } = render(<OpenButton isDev={false} isBlueprint={false} setShow={jest.fn()} />);
        expect(screen.getByRole('button')).toBeDisabled();

        rerender(<OpenButton isDev={true} isBlueprint={false} setShow={jest.fn()} />);
        expect(screen.getByRole('button')).not.toBeDisabled();

        rerender(<OpenButton isDev={false} isBlueprint={true} setShow={jest.fn()} />);
        expect(screen.getByRole('button')).not.toBeDisabled();
    });

    test('should call setShow with true when button is clicked and not disabled', () => {
        const setShowMock = jest.fn();
        render(<OpenButton isDev={true} isBlueprint={false} setShow={setShowMock} />);

        fireEvent.click(screen.getByRole('button'));
        expect(setShowMock).toHaveBeenCalledWith(true);
    });

    test('should not call setShow when button is disabled and clicked', () => {
        const setShowMock = jest.fn();
        render(<OpenButton isDev={false} isBlueprint={false} setShow={setShowMock} />);

        fireEvent.click(screen.getByRole('button'));
        expect(setShowMock).not.toHaveBeenCalled();
    });
});